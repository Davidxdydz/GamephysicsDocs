<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Game Physics Template: Renderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Game Physics Template<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A template for game physics in C++ WEBGPU</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_renderer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_renderer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Renderer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_renderer.html" title="Renderer.">Renderer</a>.  
 <a href="class_renderer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_renderer_8h_source.html">Renderer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_renderer_1_1_lighting_uniforms.html">LightingUniforms</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniform buffer for lighting.  <a href="struct_renderer_1_1_lighting_uniforms.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_renderer_1_1_render_uniforms.html">RenderUniforms</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Essential uniform buffer for rendering.  <a href="struct_renderer_1_1_render_uniforms.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4169835c479f7a9732d28c1cab078378"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#a4169835c479f7a9732d28c1cab078378">DrawFlags</a> { <a class="el" href="class_renderer.html#a4169835c479f7a9732d28c1cab078378a82d70b42c0815641010b04f37dac9c19">unlit</a> = 1 &lt;&lt; 0
, <a class="el" href="class_renderer.html#a4169835c479f7a9732d28c1cab078378a9dec3ab189b630060542e4fccf90e2e6">dontCull</a> = 1 &lt;&lt; 1
 }</td></tr>
<tr class="memdesc:a4169835c479f7a9732d28c1cab078378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to modify the rendering of objects.  <a href="class_renderer.html#a4169835c479f7a9732d28c1cab078378">More...</a><br /></td></tr>
<tr class="separator:a4169835c479f7a9732d28c1cab078378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d77738474a2d5c73030ab4bd7ca4f7"><td class="memItemLeft" align="right" valign="top"><a id="a71d77738474a2d5c73030ab4bd7ca4f7" name="a71d77738474a2d5c73030ab4bd7ca4f7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#a71d77738474a2d5c73030ab4bd7ca4f7">UniformFlags</a> { <b>cullingPlane</b> = 1 &lt;&lt; 0
 }</td></tr>
<tr class="memdesc:a71d77738474a2d5c73030ab4bd7ca4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If enabled, the renderer will draw the culling plane. <br /></td></tr>
<tr class="separator:a71d77738474a2d5c73030ab4bd7ca4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5dc807ac11501e642f5e12953ead81b5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#a5dc807ac11501e642f5e12953ead81b5">drawCube</a> (glm::vec3 position=vec3(0), glm::quat rotation=glm::quat(vec3(0)), glm::vec3 scale=vec3(1), glm::vec4 color=vec4(1), uint32_t flags=0)</td></tr>
<tr class="memdesc:a5dc807ac11501e642f5e12953ead81b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a cube in the next frame.  <br /></td></tr>
<tr class="separator:a5dc807ac11501e642f5e12953ead81b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef61eb3bf93e08098b15b0122629ab34"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#aef61eb3bf93e08098b15b0122629ab34">drawSphere</a> (glm::vec3 position=vec3(0), float radius=1, glm::vec4 color=vec4(1), uint32_t flags=0)</td></tr>
<tr class="memdesc:aef61eb3bf93e08098b15b0122629ab34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a sphere in the next frame.  <br /></td></tr>
<tr class="separator:aef61eb3bf93e08098b15b0122629ab34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb132fad20503f1c1c72ee45dd13507d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#adb132fad20503f1c1c72ee45dd13507d">drawEllipsoid</a> (glm::vec3 position=vec3(0), glm::quat rotation=glm::quat(vec3(0)), glm::vec3 scale=vec3(1), glm::vec4 color=vec4(1), uint32_t flags=0)</td></tr>
<tr class="memdesc:adb132fad20503f1c1c72ee45dd13507d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an ellipsoid in the next frame.  <br /></td></tr>
<tr class="separator:adb132fad20503f1c1c72ee45dd13507d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbb8761fb312fda9458695156c22409"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#a8dbb8761fb312fda9458695156c22409">drawQuad</a> (glm::vec3 position=vec3(0), glm::quat rotation=glm::quat(vec3(0)), glm::vec2 scale=glm::vec2(1), glm::vec4 color=vec4(1), uint32_t flags=0)</td></tr>
<tr class="memdesc:a8dbb8761fb312fda9458695156c22409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a quad in the next frame.  <br /></td></tr>
<tr class="separator:a8dbb8761fb312fda9458695156c22409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe102f5a97b649e3152a9c521059dd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#a9fe102f5a97b649e3152a9c521059dd8">drawLine</a> (glm::vec3 position1, glm::vec3 position2, glm::vec3 color)</td></tr>
<tr class="memdesc:a9fe102f5a97b649e3152a9c521059dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a line in the next frame.  <br /></td></tr>
<tr class="separator:a9fe102f5a97b649e3152a9c521059dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a834c0557783538d8a7aeb8a8e40c09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#a7a834c0557783538d8a7aeb8a8e40c09">drawLine</a> (glm::vec3 position1, glm::vec3 position2, glm::vec3 color1, glm::vec3 color2)</td></tr>
<tr class="memdesc:a7a834c0557783538d8a7aeb8a8e40c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a line with a color gradient in the next frame.  <br /></td></tr>
<tr class="separator:a7a834c0557783538d8a7aeb8a8e40c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311857ddcd83e99dad904a1b6e0e3ba9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#a311857ddcd83e99dad904a1b6e0e3ba9">drawWireCube</a> (glm::vec3 position, glm::vec3 scale, glm::vec3 color)</td></tr>
<tr class="memdesc:a311857ddcd83e99dad904a1b6e0e3ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wire cube in the next frame.  <br /></td></tr>
<tr class="separator:a311857ddcd83e99dad904a1b6e0e3ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8b573b398c762206153df6bf9cd56a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#abc8b573b398c762206153df6bf9cd56a">drawImage</a> (std::vector&lt; float &gt; data, int height, int width, <a class="el" href="class_colormap.html">Colormap</a> colormap=<a class="el" href="class_colormap.html">Colormap</a>(&quot;hot&quot;), glm::vec2 screenPosition={0, 0}, glm::vec2 screenSize={1, 1})</td></tr>
<tr class="memdesc:abc8b573b398c762206153df6bf9cd56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an image in the next frame.  <br /></td></tr>
<tr class="separator:abc8b573b398c762206153df6bf9cd56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9b07e86e4097caadaeddb1db492efd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#a9d9b07e86e4097caadaeddb1db492efd">drawImage</a> (std::vector&lt; float &gt; data, int height, int width, float vmin, float vmax, <a class="el" href="class_colormap.html">Colormap</a> colormap=<a class="el" href="class_colormap.html">Colormap</a>(&quot;hot&quot;), glm::vec2 screenPosition={0, 0}, glm::vec2 screenSize={1, 1})</td></tr>
<tr class="memdesc:a9d9b07e86e4097caadaeddb1db492efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an image in the next frame.  <br /></td></tr>
<tr class="separator:a9d9b07e86e4097caadaeddb1db492efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd05a78cdcb991d13fc416f5c65ed348"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#abd05a78cdcb991d13fc416f5c65ed348">objectCount</a> ()</td></tr>
<tr class="memdesc:abd05a78cdcb991d13fc416f5c65ed348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of spheres, ellipsoids, cubes and quads to be drawn next frame.  <br /></td></tr>
<tr class="separator:abd05a78cdcb991d13fc416f5c65ed348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af545029c609fd3f68353fc35a9740cec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#af545029c609fd3f68353fc35a9740cec">lineCount</a> ()</td></tr>
<tr class="memdesc:af545029c609fd3f68353fc35a9740cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of lines to be drawn next frame.  <br /></td></tr>
<tr class="separator:af545029c609fd3f68353fc35a9740cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977d48a68943f2d28ae208973f7aeff1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#a977d48a68943f2d28ae208973f7aeff1">imageCount</a> ()</td></tr>
<tr class="memdesc:a977d48a68943f2d28ae208973f7aeff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of images to be drawn next frame.  <br /></td></tr>
<tr class="separator:a977d48a68943f2d28ae208973f7aeff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ab104babf57ae6fa1c95ed2197a3dc"><td class="memItemLeft" align="right" valign="top"><a id="a12ab104babf57ae6fa1c95ed2197a3dc" name="a12ab104babf57ae6fa1c95ed2197a3dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onFrame</b> ()</td></tr>
<tr class="memdesc:a12ab104babf57ae6fa1c95ed2197a3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw all current objects to the screen. <br /></td></tr>
<tr class="separator:a12ab104babf57ae6fa1c95ed2197a3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf56c18f874aeb7c403bbb8ed1bb58c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_renderer.html#acf56c18f874aeb7c403bbb8ed1bb58c1">isRunning</a> ()</td></tr>
<tr class="memdesc:acf56c18f874aeb7c403bbb8ed1bb58c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the window is still open. If the window is closed, the rendering engine will stop.  <br /></td></tr>
<tr class="separator:acf56c18f874aeb7c403bbb8ed1bb58c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf40c24ac42b21a929c6a06408a6aa08"><td class="memItemLeft" align="right" valign="top"><a id="abf40c24ac42b21a929c6a06408a6aa08" name="abf40c24ac42b21a929c6a06408a6aa08"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onResize</b> ()</td></tr>
<tr class="memdesc:abf40c24ac42b21a929c6a06408a6aa08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function that is called when the window is resized. <br /></td></tr>
<tr class="separator:abf40c24ac42b21a929c6a06408a6aa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd580031d620755bb07d89295134b920"><td class="memItemLeft" align="right" valign="top"><a id="afd580031d620755bb07d89295134b920" name="afd580031d620755bb07d89295134b920"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearScene</b> ()</td></tr>
<tr class="memdesc:afd580031d620755bb07d89295134b920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all objects that are currently drawn. <br /></td></tr>
<tr class="separator:afd580031d620755bb07d89295134b920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4f813b6b6b06c8169f29fff63e540a"><td class="memItemLeft" align="right" valign="top"><a id="a6a4f813b6b6b06c8169f29fff63e540a" name="a6a4f813b6b6b06c8169f29fff63e540a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setPresentMode</b> (wgpu::PresentMode mode)</td></tr>
<tr class="memdesc:a6a4f813b6b6b06c8169f29fff63e540a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable frame rate synchronization. <br /></td></tr>
<tr class="separator:a6a4f813b6b6b06c8169f29fff63e540a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a98805f621abf552caa5f411e35b2485f"><td class="memItemLeft" align="right" valign="top"><a id="a98805f621abf552caa5f411e35b2485f" name="a98805f621abf552caa5f411e35b2485f"></a>
glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><b>backgroundColor</b> = {0.05f, 0.05f, 0.05f}</td></tr>
<tr class="memdesc:a98805f621abf552caa5f411e35b2485f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The background color of the scene. <br /></td></tr>
<tr class="separator:a98805f621abf552caa5f411e35b2485f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8312db8d2875c462e74d0fc9a44e514e"><td class="memItemLeft" align="right" valign="top"><a id="a8312db8d2875c462e74d0fc9a44e514e" name="a8312db8d2875c462e74d0fc9a44e514e"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>defineGUI</b> = nullptr</td></tr>
<tr class="memdesc:a8312db8d2875c462e74d0fc9a44e514e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called once per frame inside an ImGui context. <br /></td></tr>
<tr class="separator:a8312db8d2875c462e74d0fc9a44e514e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fed794dd04af30a7ff5f6fccd169849"><td class="memItemLeft" align="right" valign="top"><a id="a0fed794dd04af30a7ff5f6fccd169849" name="a0fed794dd04af30a7ff5f6fccd169849"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>lastDrawTime</b> = 0</td></tr>
<tr class="memdesc:a0fed794dd04af30a7ff5f6fccd169849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the time taken up by the actual rendering last frame. <br /></td></tr>
<tr class="separator:a0fed794dd04af30a7ff5f6fccd169849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3534ee4ebbccd4997f500e3217cc8f2"><td class="memItemLeft" align="right" valign="top"><a id="ac3534ee4ebbccd4997f500e3217cc8f2" name="ac3534ee4ebbccd4997f500e3217cc8f2"></a>
<a class="el" href="struct_renderer_1_1_render_uniforms.html">RenderUniforms</a>&#160;</td><td class="memItemRight" valign="bottom"><b>renderUniforms</b></td></tr>
<tr class="separator:ac3534ee4ebbccd4997f500e3217cc8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f7a89183bbd11f091161a568b12866"><td class="memItemLeft" align="right" valign="top"><a id="a62f7a89183bbd11f091161a568b12866" name="a62f7a89183bbd11f091161a568b12866"></a>
<a class="el" href="struct_renderer_1_1_lighting_uniforms.html">LightingUniforms</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lightingUniforms</b></td></tr>
<tr class="separator:a62f7a89183bbd11f091161a568b12866"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5ab9bab1dc117572aebc39a7b0d8c15b"><td class="memItemLeft" align="right" valign="top"><a id="a5ab9bab1dc117572aebc39a7b0d8c15b" name="a5ab9bab1dc117572aebc39a7b0d8c15b"></a>
static <a class="el" href="class_camera.html">Camera</a>&#160;</td><td class="memItemRight" valign="bottom"><b>camera</b> = <a class="el" href="class_camera.html">Camera</a>()</td></tr>
<tr class="memdesc:a5ab9bab1dc117572aebc39a7b0d8c15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main camera of the scene. <br /></td></tr>
<tr class="separator:a5ab9bab1dc117572aebc39a7b0d8c15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_renderer.html" title="Renderer.">Renderer</a>. </p>
<p>This class is the main interface to the rendering engine. It provides functions to draw cubes, spheres, lines, images, etc. One instance of this class should be created in the main function of the application. The class is responsible for creating the window, initializing the device, and handling the rendering. After each onFrame call, the rendering engine will draw the scene and present it to the screen. renderer.clearScreen() should be called at the beginning of each frame to clear all added draw objects. Otherwise, the objects will be drawn in every frame. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a4169835c479f7a9732d28c1cab078378" name="a4169835c479f7a9732d28c1cab078378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4169835c479f7a9732d28c1cab078378">&#9670;&#160;</a></span>DrawFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_renderer.html#a4169835c479f7a9732d28c1cab078378">Renderer::DrawFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to modify the rendering of objects. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4169835c479f7a9732d28c1cab078378a82d70b42c0815641010b04f37dac9c19" name="a4169835c479f7a9732d28c1cab078378a82d70b42c0815641010b04f37dac9c19"></a>unlit&#160;</td><td class="fielddoc"><p>The object will be drawn without lighting, meaning full brightness. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4169835c479f7a9732d28c1cab078378a9dec3ab189b630060542e4fccf90e2e6" name="a4169835c479f7a9732d28c1cab078378a9dec3ab189b630060542e4fccf90e2e6"></a>dontCull&#160;</td><td class="fielddoc"><p>The object will be drawn even if it is cut by the culling plane. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5dc807ac11501e642f5e12953ead81b5" name="a5dc807ac11501e642f5e12953ead81b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc807ac11501e642f5e12953ead81b5">&#9670;&#160;</a></span>drawCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Renderer::drawCube </td>
          <td>(</td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>position</em> = <code>vec3(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::quat&#160;</td>
          <td class="paramname"><em>rotation</em> = <code>glm::quat(vec3(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>scale</em> = <code>vec3(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>color</em> = <code>vec4(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a cube in the next frame. </p>
<p>Call this function every frame you want to draw a cube</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The center of the cube </td></tr>
    <tr><td class="paramname">rotation</td><td>The rotation of the cube </td></tr>
    <tr><td class="paramname">scale</td><td>The scale of the cube. scale (1,1,1) will result in a cube with side length 1 </td></tr>
    <tr><td class="paramname">color</td><td>The color of the cube: (r, g, b, a) </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to modify the cube: <a class="el" href="class_renderer.html#a4169835c479f7a9732d28c1cab078378" title="Flags to modify the rendering of objects.">Renderer::DrawFlags</a>. Can be combined with bitwise OR. Possible flags: <pre class="fragment">- unlit: The cube will be drawn without lighting, meaning full brightness

- dontCull: The cube will be drawn even if it is cut by the culling plane
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The id of the cube. </dd></dl>

</div>
</div>
<a id="adb132fad20503f1c1c72ee45dd13507d" name="adb132fad20503f1c1c72ee45dd13507d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb132fad20503f1c1c72ee45dd13507d">&#9670;&#160;</a></span>drawEllipsoid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Renderer::drawEllipsoid </td>
          <td>(</td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>position</em> = <code>vec3(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::quat&#160;</td>
          <td class="paramname"><em>rotation</em> = <code>glm::quat(vec3(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>scale</em> = <code>vec3(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>color</em> = <code>vec4(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw an ellipsoid in the next frame. </p>
<p>Call this function every frame you want to draw an ellipsoid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The center of the ellipsoid </td></tr>
    <tr><td class="paramname">rotation</td><td>The rotation of the ellipsoid </td></tr>
    <tr><td class="paramname">scale</td><td>The scale of the ellipsoid. scale (1,1,1) will result in a sphere with radius 1, scale (1,2,1) will result in an ellipsoid with radius 1 in x and z direction and 2 in y direction </td></tr>
    <tr><td class="paramname">color</td><td>The color of the ellipsoid: (r, g, b, a) </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to modify the ellipsoid: <a class="el" href="class_renderer.html#a4169835c479f7a9732d28c1cab078378" title="Flags to modify the rendering of objects.">Renderer::DrawFlags</a>. Can be combined with bitwise OR. Possible flags: <pre class="fragment">- unlit: The ellipsoid will be drawn without lighting, meaning full brightness

- dontCull: The ellipsoid will be drawn even if it is cut by the culling plane
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The id of the ellipsoid. </dd></dl>

</div>
</div>
<a id="abc8b573b398c762206153df6bf9cd56a" name="abc8b573b398c762206153df6bf9cd56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8b573b398c762206153df6bf9cd56a">&#9670;&#160;</a></span>drawImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Renderer::drawImage </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_colormap.html">Colormap</a>&#160;</td>
          <td class="paramname"><em>colormap</em> = <code><a class="el" href="class_colormap.html">Colormap</a>(&quot;hot&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec2&#160;</td>
          <td class="paramname"><em>screenPosition</em> = <code>{0,&#160;0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec2&#160;</td>
          <td class="paramname"><em>screenSize</em> = <code>{1,&#160;1}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw an image in the next frame. </p>
<p>Call this function every frame you want to draw an image.</p>
<p><em>The colormap will automatically adjust to the data!</em> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The image data. The data should be a 1D vectro of floats, where each float represents a pixel. Pixel <em>rows</em> should be concatenated. </td></tr>
    <tr><td class="paramname">height</td><td>Number of pixels in y direction of the input data </td></tr>
    <tr><td class="paramname">width</td><td>Number of pixels in x direction of the input data </td></tr>
    <tr><td class="paramname">colormap</td><td>The colormap to use. Default is "hot". See <code><a class="el" href="class_colormap.html">Colormap</a></code> documentation for available colormaps (all from matplotlib). </td></tr>
    <tr><td class="paramname">screenPosition</td><td>The center of the image on the screen. (0,0) is the middle of the screen, (1,1) is the top right corner. </td></tr>
    <tr><td class="paramname">screenSize</td><td>The size of the image on the screen. (1,1) will fill the whole screen. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d9b07e86e4097caadaeddb1db492efd" name="a9d9b07e86e4097caadaeddb1db492efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9b07e86e4097caadaeddb1db492efd">&#9670;&#160;</a></span>drawImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Renderer::drawImage </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_colormap.html">Colormap</a>&#160;</td>
          <td class="paramname"><em>colormap</em> = <code><a class="el" href="class_colormap.html">Colormap</a>(&quot;hot&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec2&#160;</td>
          <td class="paramname"><em>screenPosition</em> = <code>{0,&#160;0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec2&#160;</td>
          <td class="paramname"><em>screenSize</em> = <code>{1,&#160;1}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw an image in the next frame. </p>
<p>Call this function every frame you want to draw an image. Use this if you do <em>not</em> want the colormap range to change each frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The image data. The data should be a 1D vectro of floats, where each float represents a pixel. Pixel <em>rows</em> should be concatenated. </td></tr>
    <tr><td class="paramname">height</td><td>Number of pixels in y direction of the input data </td></tr>
    <tr><td class="paramname">width</td><td>Number of pixels in x direction of the input data </td></tr>
    <tr><td class="paramname">vmin</td><td>The minimum value of the data. All values below this will be clipped. </td></tr>
    <tr><td class="paramname">vmax</td><td>The maximum value of the data. All values above this will be clipped. </td></tr>
    <tr><td class="paramname">colormap</td><td>The colormap to use. Default is "hot". See <code><a class="el" href="class_colormap.html">Colormap</a></code> documentation for available colormaps (all from matplotlib). </td></tr>
    <tr><td class="paramname">screenPosition</td><td>The center of the image on the screen. (0,0) is the middle of the screen, (1,1) is the top right corner. </td></tr>
    <tr><td class="paramname">screenSize</td><td>The size of the image on the screen. (1,1) will fill the whole screen. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fe102f5a97b649e3152a9c521059dd8" name="a9fe102f5a97b649e3152a9c521059dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe102f5a97b649e3152a9c521059dd8">&#9670;&#160;</a></span>drawLine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Renderer::drawLine </td>
          <td>(</td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>position1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>position2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a line in the next frame. </p>
<p>Call this function every frame you want to draw a line</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position1</td><td>The start of the line </td></tr>
    <tr><td class="paramname">position2</td><td>The end of the line </td></tr>
    <tr><td class="paramname">color</td><td>The color of the line: (r, g, b). lines do not support transparency </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a834c0557783538d8a7aeb8a8e40c09" name="a7a834c0557783538d8a7aeb8a8e40c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a834c0557783538d8a7aeb8a8e40c09">&#9670;&#160;</a></span>drawLine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Renderer::drawLine </td>
          <td>(</td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>position1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>position2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>color1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>color2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a line with a color gradient in the next frame. </p>
<p>Call this function every frame you want to draw a line</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position1</td><td>The start of the line </td></tr>
    <tr><td class="paramname">position2</td><td>The end of the line </td></tr>
    <tr><td class="paramname">color1</td><td>The color of the start of the line: (r, g, b). </td></tr>
    <tr><td class="paramname">color2</td><td>The color of the end of the line: (r, g, b). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dbb8761fb312fda9458695156c22409" name="a8dbb8761fb312fda9458695156c22409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbb8761fb312fda9458695156c22409">&#9670;&#160;</a></span>drawQuad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Renderer::drawQuad </td>
          <td>(</td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>position</em> = <code>vec3(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::quat&#160;</td>
          <td class="paramname"><em>rotation</em> = <code>glm::quat(vec3(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec2&#160;</td>
          <td class="paramname"><em>scale</em> = <code>glm::vec2(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>color</em> = <code>vec4(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a quad in the next frame. </p>
<p>Call this function every frame you want to draw a quad</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The center of the quad </td></tr>
    <tr><td class="paramname">rotation</td><td>The rotation of the quad </td></tr>
    <tr><td class="paramname">scale</td><td>The scale of the quad. scale (1,1) will result in a quad with side length 1. </td></tr>
    <tr><td class="paramname">color</td><td>The color of the quad: (r, g, b, a) </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to modify the quad: <a class="el" href="class_renderer.html#a4169835c479f7a9732d28c1cab078378" title="Flags to modify the rendering of objects.">Renderer::DrawFlags</a>. Can be combined with bitwise OR. Possible flags: <pre class="fragment">- unlit: The quad will be drawn without lighting, meaning full brightness

- dontCull: The quad will be drawn even if it is cut by the culling plane
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The id of the quad. </dd></dl>

</div>
</div>
<a id="aef61eb3bf93e08098b15b0122629ab34" name="aef61eb3bf93e08098b15b0122629ab34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef61eb3bf93e08098b15b0122629ab34">&#9670;&#160;</a></span>drawSphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Renderer::drawSphere </td>
          <td>(</td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>position</em> = <code>vec3(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>color</em> = <code>vec4(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a sphere in the next frame. </p>
<p>Call this function every frame you want to draw a sphere</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The center of the sphere </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the sphere </td></tr>
    <tr><td class="paramname">color</td><td>The color of the sphere: (r, g, b, a) </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to modify the sphere: <a class="el" href="class_renderer.html#a4169835c479f7a9732d28c1cab078378" title="Flags to modify the rendering of objects.">Renderer::DrawFlags</a>. Can be combined with bitwise OR. Possible flags: <pre class="fragment">- unlit: The sphere will be drawn without lighting, meaning full brightness

- dontCull: The sphere will be drawn even if it is cut by the culling plane
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The id of the sphere. </dd></dl>

</div>
</div>
<a id="a311857ddcd83e99dad904a1b6e0e3ba9" name="a311857ddcd83e99dad904a1b6e0e3ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311857ddcd83e99dad904a1b6e0e3ba9">&#9670;&#160;</a></span>drawWireCube()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Renderer::drawWireCube </td>
          <td>(</td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a wire cube in the next frame. </p>
<p>Call this function every frame you want to draw a wire cube</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The center of the cube </td></tr>
    <tr><td class="paramname">scale</td><td>The scale of the cube. scale (1,1,1) will result in a cube with side length 1 </td></tr>
    <tr><td class="paramname">color</td><td>The color of the wire cube: (r, g, b) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a977d48a68943f2d28ae208973f7aeff1" name="a977d48a68943f2d28ae208973f7aeff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977d48a68943f2d28ae208973f7aeff1">&#9670;&#160;</a></span>imageCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Renderer::imageCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of images to be drawn next frame. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of images to be drawn next frame </dd></dl>

</div>
</div>
<a id="acf56c18f874aeb7c403bbb8ed1bb58c1" name="acf56c18f874aeb7c403bbb8ed1bb58c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf56c18f874aeb7c403bbb8ed1bb58c1">&#9670;&#160;</a></span>isRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Renderer::isRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the window is still open. If the window is closed, the rendering engine will stop. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the window is still open, false if the window is closed </dd></dl>

</div>
</div>
<a id="af545029c609fd3f68353fc35a9740cec" name="af545029c609fd3f68353fc35a9740cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af545029c609fd3f68353fc35a9740cec">&#9670;&#160;</a></span>lineCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Renderer::lineCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of lines to be drawn next frame. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of lines to be drawn next frame </dd></dl>

</div>
</div>
<a id="abd05a78cdcb991d13fc416f5c65ed348" name="abd05a78cdcb991d13fc416f5c65ed348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd05a78cdcb991d13fc416f5c65ed348">&#9670;&#160;</a></span>objectCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Renderer::objectCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of spheres, ellipsoids, cubes and quads to be drawn next frame. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of objects to be drawn next frame </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_renderer_8h_source.html">Renderer.h</a></li>
<li>src/Renderer.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_renderer.html">Renderer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
